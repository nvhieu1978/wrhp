1
00:00:07,010 --> 00:00:11,960
Before I start with today's lecture,
I want to point out that there is a

2
00:00:11,960 --> 00:00:16,700
recent development in the playground
that fixes an issue that many of

3
00:00:16,700 --> 00:00:18,080
you have been complaining about.

4
00:00:18,410 --> 00:00:22,100
Namely that sometimes the
timeout that was hard-coded into

5
00:00:22,100 --> 00:00:24,260
the playground was too short.

6
00:00:24,560 --> 00:00:29,660
So sometimes your simulations failed
because the simulation just took more

7
00:00:29,660 --> 00:00:31,610
time than this timeout specified.

8
00:00:32,119 --> 00:00:35,180
And it was very difficult to change
the timeout because it was hard-coded.

9
00:00:35,180 --> 00:00:39,320
So you would have to change the
source code and then recompile it.

10
00:00:40,160 --> 00:00:47,310
And now there's an option when you start
the Plutus playground server and -i and

11
00:00:47,310 --> 00:00:52,820
then you can specify something like 120
seconds to set the timeout to two minutes.

12
00:00:55,695 --> 00:01:02,160
When I explained the extended UTxO model
in the first lecture, I explained it in

13
00:01:02,160 --> 00:01:08,460
order to unlock a script address, the
script attached to the address is run.

14
00:01:08,940 --> 00:01:11,810
And that script gets three
pieces of input, the datum,

15
00:01:11,810 --> 00:01:13,620
the redeemer and the context.

16
00:01:14,130 --> 00:01:18,810
And in the second lecture, we saw
examples of that and we saw how

17
00:01:18,810 --> 00:01:20,470
that actually works in Haskell.

18
00:01:21,510 --> 00:01:28,260
We saw the low level implementation where
all three arguments, datum, redeemer, and

19
00:01:28,260 --> 00:01:30,930
context are represented by the data type.

20
00:01:31,680 --> 00:01:35,760
But I also mentioned that in practice
that is not used and we use instead

21
00:01:35,760 --> 00:01:40,980
the typed version, where datum and
redeemer can be customed types, as

22
00:01:40,980 --> 00:01:46,680
long as they implement the is data type
class and where the third argument,

23
00:01:46,680 --> 00:01:50,550
the context is of type script context.

24
00:01:51,210 --> 00:01:56,760
And the example we have seen so far only
looked at the datum and the redeemer,

25
00:01:56,970 --> 00:01:59,100
but we have always ignored the context.

26
00:02:00,255 --> 00:02:02,205
But the context is of
course very important.

27
00:02:02,925 --> 00:02:09,394
So in this lecture, we want to start
looking at the context and this script

28
00:02:09,394 --> 00:02:18,234
context type it's defined in package
plutus-ledger-api which is a package

29
00:02:18,234 --> 00:02:23,115
that until now we haven't needed,
but now we do need it and I also

30
00:02:23,115 --> 00:02:25,995
included it in this week's cabal file.

31
00:02:27,015 --> 00:02:34,815
And the context is in module
Plutus.V1.Ledger.Contexts and

32
00:02:34,815 --> 00:02:39,525
we see the definition here,
so the type script context.

33
00:02:40,215 --> 00:02:45,555
And we see it as a record type with
two fields, one of type Tx info,

34
00:02:45,644 --> 00:02:48,285
which is the most interesting one.

35
00:02:48,795 --> 00:02:54,315
And then the second field of type script
purpose and the script purpose type

36
00:02:54,315 --> 00:02:56,175
is defined in the same module here.

37
00:02:57,135 --> 00:03:02,685
And it describes for which
purpose the script is run.

38
00:03:02,775 --> 00:03:06,945
So the most important purpose for us
will be this one, the spending purpose.

39
00:03:07,455 --> 00:03:11,655
So this is what we have talked
about until now in the context

40
00:03:11,655 --> 00:03:13,635
of the extended UTxO model.

41
00:03:14,404 --> 00:03:19,905
So this is when a script is run
in order to validate spending

42
00:03:19,965 --> 00:03:24,345
input for a transaction, but
there are three other purposes.

43
00:03:24,825 --> 00:03:27,585
The second most important
one is the minting one.

44
00:03:27,765 --> 00:03:33,395
So that comes into play when you want
to define a native token and then this

45
00:03:33,555 --> 00:03:39,025
purpose of this script would be to
describe under which circumstances the

46
00:03:39,025 --> 00:03:43,285
native token can be minted or burned.

47
00:03:44,490 --> 00:03:48,840
And then there are two more
purposes, rewarding and certifying.

48
00:03:48,840 --> 00:03:55,410
So rewarding seems to be related to
staking and certifying to certificates

49
00:03:55,410 --> 00:03:57,070
like delegation certificates.

50
00:03:58,520 --> 00:04:04,380
But first we will concentrate
on the spending purpose.

51
00:04:05,580 --> 00:04:12,510
So now the actual context is in
this field of type Tx info, which is

52
00:04:12,510 --> 00:04:14,790
defined also in the same module here.

53
00:04:16,110 --> 00:04:20,670
And this basically describes, I mean, it's
an abbreviation for a transaction info,

54
00:04:21,029 --> 00:04:23,610
so it describes the spending transaction.

55
00:04:23,910 --> 00:04:31,590
I always say that in the UTxO model
that Cardano uses, the context of

56
00:04:31,590 --> 00:04:33,810
validation is the spending transaction.

57
00:04:34,230 --> 00:04:36,370
So the transaction and
its inputs and outputs.

58
00:04:37,990 --> 00:04:41,715
And that is expressed
in this Tx info type.

59
00:04:41,924 --> 00:04:45,405
So there are a couple of fields that
are basically global to the transaction.

60
00:04:45,674 --> 00:04:49,395
And then in particular, we have
the list of all the inputs of the

61
00:04:49,395 --> 00:04:52,815
transaction and the list of all
the outputs of the transaction.

62
00:04:52,865 --> 00:04:59,414
And these Tx in info and Tx out
types, again have lots of fields

63
00:04:59,414 --> 00:05:04,695
to allow you to drill into each
individual input respectively output.

64
00:05:06,015 --> 00:05:12,375
So let's go through the Tx info fields
briefly, so Tx info inputs the inputs,

65
00:05:12,375 --> 00:05:18,895
Tx info outputs the outputs, Tx info
fee is the fee, the transaction fee, Tx

66
00:05:18,895 --> 00:05:26,385
info forge is the amount of newly forged
native tokens or if it's a negative

67
00:05:26,385 --> 00:05:28,575
amount, newly burned native tokens.

68
00:05:28,605 --> 00:05:34,125
So we'll come to that in a later lecture,
then we have a list of certificates,

69
00:05:34,305 --> 00:05:36,545
something like delegation certificates.

70
00:05:37,795 --> 00:05:44,885
Then staking withdrawals,
so withdrawals from rewards.

71
00:05:46,035 --> 00:05:53,055
Then Tx info valid range denotes
the time range in which this

72
00:05:53,085 --> 00:05:54,285
transaction will be valid.

73
00:05:54,345 --> 00:05:59,655
And we'll talk about that in
much more detail in a minute.

74
00:06:00,735 --> 00:06:05,535
Then the Tx info signatories,
that's the list of public keys

75
00:06:05,535 --> 00:06:07,725
that have signed this transaction.

76
00:06:09,285 --> 00:06:15,750
Tx info data, I mentioned before
that spending transactions, I mean,

77
00:06:15,870 --> 00:06:21,460
transactions that spend a script
output need to include the datum of

78
00:06:21,520 --> 00:06:28,950
that script output whereas producing
transactions that send money to a script

79
00:06:28,950 --> 00:06:32,070
address have an output at the script
address, only have to include the hash.

80
00:06:33,000 --> 00:06:37,780
So this field Tx info data is
basically a dictionary from datum hash

81
00:06:37,799 --> 00:06:43,799
to data to include the fully datum
values belonging to a given hash.

82
00:06:44,490 --> 00:06:48,599
There's also mentioned before,
spending transactions always have to

83
00:06:48,599 --> 00:06:54,060
include the datum of the inputs they
spent, but producing transactions

84
00:06:54,090 --> 00:06:55,500
optionally can also do that.

85
00:06:56,580 --> 00:07:01,799
And finally, Tx info id is
the id of this transition.

86
00:07:04,055 --> 00:07:07,224
This brings us to an interesting dilemma.

87
00:07:08,305 --> 00:07:13,284
I have stressed several times that
one of the big advantages that the

88
00:07:13,284 --> 00:07:18,505
Cardano UTxO model has over something
like Ethereum is the fact that

89
00:07:18,505 --> 00:07:20,724
validation can help them in the wallet.

90
00:07:21,565 --> 00:07:27,895
So as I explained before, transactions
can still fail because a transaction

91
00:07:27,895 --> 00:07:33,360
can consume an input that when the
transaction arrives on the blockchain

92
00:07:33,420 --> 00:07:38,130
at the node for validation has already
been consumed by somebody else.

93
00:07:38,610 --> 00:07:44,190
But in that case, the transaction simply
fails without having to pay fees, but

94
00:07:44,190 --> 00:07:47,580
what can never happen or should never
happen under normal circumstances

95
00:07:47,580 --> 00:07:53,280
is that a validation script runs and
then fails because you can always

96
00:07:53,280 --> 00:07:57,930
run the script under exactly the same
conditions in the wallet already.

97
00:07:57,960 --> 00:08:01,830
So you see that it would fail
before you ever submit it.

98
00:08:03,150 --> 00:08:06,060
And that is a very important
and a very nice feature.

99
00:08:06,420 --> 00:08:13,020
But if you think about it, it's not
clear how to manage time in that

100
00:08:13,590 --> 00:08:18,390
context, because time is obviously
important because we want to be able to

101
00:08:18,390 --> 00:08:23,490
express validation logic that says that
a certain transaction is only valid.

102
00:08:24,285 --> 00:08:28,425
After a certain time has been reached
or before certain time has been reached.

103
00:08:28,905 --> 00:08:32,505
You saw an example of that in the
very first example, the auction

104
00:08:32,505 --> 00:08:37,635
example, where bids are only allowed
until the deadline has been reached

105
00:08:37,695 --> 00:08:42,525
and the close endpoint can only be
called after the deadline has passed.

106
00:08:43,215 --> 00:08:45,795
And if you think about that,
that seems to be a contradiction

107
00:08:46,335 --> 00:08:49,335
because time is obviously flowing.

108
00:08:49,665 --> 00:08:55,365
So when you try to validate a transaction
that you're constructing in your

109
00:08:55,365 --> 00:09:01,275
wallet, the time that you do that in
the wallet can of course be different

110
00:09:01,275 --> 00:09:05,445
to the time that the transaction
arrives at a node for validation.

111
00:09:06,015 --> 00:09:10,425
So it's not clear how to bring these two
together to on the one hand handle time.

112
00:09:10,425 --> 00:09:16,155
But on the other hand guarantee that
validation is deterministic in the sense

113
00:09:16,155 --> 00:09:21,615
that if it even only if it succeeds in the
wallet, it will also succeed in the node.

114
00:09:22,905 --> 00:09:29,865
And the way Cardano solves that is by
adding this POSIX time range field.

115
00:09:30,135 --> 00:09:36,045
Tx info valid range field to a transaction
and what that specifies, so it's...

116
00:09:36,165 --> 00:09:42,375
we you will look at that type in detail in
a moment, but basically it gives a valid

117
00:09:42,435 --> 00:09:44,895
time interval, it is a time interval.

118
00:09:45,525 --> 00:09:50,204
So it says this transaction is
valid between this and that time.

119
00:09:51,015 --> 00:09:55,905
And that is specified in the transaction,
and now when the transaction gets sent

120
00:09:55,905 --> 00:09:59,745
to the blockchain, submitted to the
blockchain and validated by a node

121
00:09:59,925 --> 00:10:05,055
then before any scripts are run some
general checks are done for example,

122
00:10:05,055 --> 00:10:09,435
that all the inputs are present and
that the balances at up and so on that

123
00:10:09,435 --> 00:10:16,995
the fees are included and run of those
checks that happens before validation

124
00:10:17,295 --> 00:10:20,145
is that the time range has changed.

125
00:10:21,194 --> 00:10:27,074
So when a node is validating, one of
these pre-checks before validation

126
00:10:27,074 --> 00:10:31,725
is the node checks the current
time and compares it to the time

127
00:10:31,725 --> 00:10:33,555
range specified in the transaction.

128
00:10:34,035 --> 00:10:37,905
And if the current time does not
fall into this time range, then

129
00:10:37,905 --> 00:10:43,365
validation fails immediately without
ever running the validator scripts.

130
00:10:44,594 --> 00:10:50,175
But that also means that if these
pre-checks succeed, then we can

131
00:10:50,175 --> 00:10:53,055
assume that the current time
does fall into this interval.

132
00:10:53,415 --> 00:10:56,714
And then validation is
completely deterministic again.

133
00:10:57,735 --> 00:11:01,125
This is just a static piece of
data attached to the transaction.

134
00:11:01,334 --> 00:11:07,635
So the result of validation does not
depend on when it is run, whether

135
00:11:07,635 --> 00:11:12,435
it's run in the wallet before
submission or in one of the nodes

136
00:11:12,944 --> 00:11:14,474
when validating a transaction.

137
00:11:16,005 --> 00:11:21,675
And this makes it possible to resolve
this apparent contradiction between

138
00:11:21,675 --> 00:11:26,625
having deterministic validation
on the one hand and taking time

139
00:11:26,625 --> 00:11:27,985
into account on the other hand.

140
00:11:28,185 --> 00:11:33,525
So the trick is to do the time check
before validation is run, and then

141
00:11:33,645 --> 00:11:38,325
during the execution of the validator
scripts, we don't have to worry about

142
00:11:38,325 --> 00:11:42,135
it anymore and if we can just assume
that the current time falls into this

143
00:11:42,135 --> 00:11:46,935
interval, because if it wouldn't then
validation wouldn't even run in the first

144
00:11:46,935 --> 00:11:50,985
place, because then validation of the
transaction would have failed before.

145
00:11:52,515 --> 00:11:59,775
By default all transactions use the
infinite time range that starts at the

146
00:11:59,775 --> 00:12:04,995
beginning of time or at the Genesis
block and lasts for all eternity.

147
00:12:05,685 --> 00:12:10,665
So such transactions will always be
valid no matter at what time they

148
00:12:10,935 --> 00:12:12,645
arrive at a node for validation.

149
00:12:13,565 --> 00:12:17,805
The only exceptions we have seen so far
were those in the auction example, because

150
00:12:17,805 --> 00:12:24,165
the bid and the close couldn't use the
infinite interval, because we made sure

151
00:12:24,165 --> 00:12:28,485
that the bid happens before the deadline
and the close after the deadline, but by

152
00:12:28,485 --> 00:12:33,765
default all transactions, including those
that you send from Daudalus for example,

153
00:12:34,355 --> 00:12:36,735
always use the infinite time range.

154
00:12:38,655 --> 00:12:41,535
There's one slight complication with this.

155
00:12:42,645 --> 00:12:47,805
And that is that or bores itself the
consensus protocol powering Cardano

156
00:12:48,615 --> 00:12:51,135
doesn't use POSIX time, time...

157
00:12:51,495 --> 00:12:52,635
it uses slots.

158
00:12:52,875 --> 00:12:59,505
So it counts slots and each slot
there's lottery happens where a slot

159
00:12:59,635 --> 00:13:03,495
there's determined, and it's got to
be, that can produce a block and so on.

160
00:13:03,944 --> 00:13:11,925
So a slot is the native measure of
time when Cardano, but Plutus uses.

161
00:13:13,725 --> 00:13:16,814
So some of this has to be converted.

162
00:13:16,845 --> 00:13:21,704
So we need to be able to convert back
and forth between real time and slots.

163
00:13:22,125 --> 00:13:25,694
And this is no problem as long
as the slot length is fixed,

164
00:13:26,085 --> 00:13:27,885
right now it is one second.

165
00:13:28,665 --> 00:13:33,345
So right now it's easy to go back
and forth between real time and slot

166
00:13:33,345 --> 00:13:37,095
numbers, but this could change in future.

167
00:13:37,335 --> 00:13:42,704
So there could be a hard fork,
some parameter change that

168
00:13:42,975 --> 00:13:44,564
will change the slot time.

169
00:13:45,615 --> 00:13:50,925
And of course, we can't know that
in advance, that may be a decision

170
00:13:50,925 --> 00:13:52,574
that is made years in the future.

171
00:13:53,595 --> 00:13:57,615
So we don't know right now what the slot
length will be in 10 years, for example.

172
00:13:58,905 --> 00:14:05,835
And that means that slot intervals specify
the transactions mustn't have a definite

173
00:14:05,865 --> 00:14:08,895
upper bound that is to find the future.

174
00:14:09,525 --> 00:14:10,454
It must only be...

175
00:14:11,834 --> 00:14:16,064
as fine the future as it is possible
to know what the slot length will be.

176
00:14:16,485 --> 00:14:18,885
And that happens to be
something like 36 hours.

177
00:14:20,115 --> 00:14:25,155
We know what the slot length will be in
the next 36 hours, because if there's

178
00:14:25,155 --> 00:14:29,055
a hard fork, if there's a change in
protocol parameters, then we know

179
00:14:29,055 --> 00:14:31,455
that at least 36 hours in advance.

180
00:14:32,925 --> 00:14:38,205
So that is something to keep in mind,
you can't specify arbitrary time ranges

181
00:14:38,235 --> 00:14:40,005
there, in the transaction interval.

182
00:14:40,965 --> 00:14:46,845
It must only be at most 36 hours in
the future, or it can be indefinite,

183
00:14:46,905 --> 00:14:49,035
so for all eternity, that's also fine.

184
00:14:49,545 --> 00:14:54,125
But if it's a fixed time, like the
deadline in our auction example when

185
00:14:54,635 --> 00:14:59,444
we submit a transaction, the deadline
basically mustn't be farther than 36

186
00:14:59,444 --> 00:15:04,755
hours in the future, then we submit
that, or the deadline could be, but

187
00:15:04,755 --> 00:15:09,194
then we must specify the deadline
is upper bound, but some other time

188
00:15:09,194 --> 00:15:13,125
that lives before the deadline that
is at most 36 hours in the future.

189
00:15:13,725 --> 00:15:17,355
So that's a slight complication
that arises from the fact that

190
00:15:17,625 --> 00:15:22,875
Plutus uses a different concept
of time then all boards itself.

191
00:15:24,345 --> 00:15:27,525
Of course, it's more convenient to use
real time, especially for real world

192
00:15:27,525 --> 00:15:34,955
contracts where you may want to specify
deadlines in real time dates, for example.

193
00:15:36,155 --> 00:15:41,435
But in order to translate back and forth
between time and slots, you have to be a

194
00:15:41,435 --> 00:15:46,775
bit careful when you submit a transaction,
when you construct transactions and set

195
00:15:46,865 --> 00:15:49,115
the slot interval or the time range.

196
00:15:49,985 --> 00:15:53,315
So let's look at this
POSIX time range type.

197
00:15:55,395 --> 00:16:03,030
And we see it's defined in module
Plutus.V1.Ledger.Time and it's just a

198
00:16:03,030 --> 00:16:11,819
type synonym for interval POSIX time,
so let's look at the interval type.

199
00:16:13,770 --> 00:16:18,810
We see interval type, the one type
parameter, and we see it's specified

200
00:16:18,810 --> 00:16:20,760
by a lower bound and upper bound.

201
00:16:21,040 --> 00:16:23,130
We can drill into those types as well.

202
00:16:23,130 --> 00:16:26,459
So in lower bound has one
construct, a lower bond, and

203
00:16:26,459 --> 00:16:29,520
then extended a and closure.

204
00:16:29,579 --> 00:16:33,390
Let's first look at closure, that's
just another name for bool and it

205
00:16:33,390 --> 00:16:37,740
specifies whether that boundary is
included in the interval or not.

206
00:16:38,849 --> 00:16:43,920
And let's look at this extended,
so this extended can just be an A,

207
00:16:44,760 --> 00:16:49,410
defined constructor, or it can be
negative infinity or positive infinity.

208
00:16:50,939 --> 00:16:56,535
Now, if we scroll down here, we see there
are a couple of convenience functions.

209
00:16:57,074 --> 00:16:59,925
So member for example, allows
us to check whether a given

210
00:16:59,925 --> 00:17:02,295
A is included in interval A.

211
00:17:02,775 --> 00:17:06,284
Provided A is the ord constraint
is an instance of the ord class,

212
00:17:06,645 --> 00:17:11,714
which means that you can compare
two As whether one is less than or

213
00:17:11,714 --> 00:17:13,694
greater than or equal to the other.

214
00:17:14,595 --> 00:17:18,734
So POSIX time, for example, is
an instance of ord as our slots.

215
00:17:20,513 --> 00:17:24,013
Interval is a smart constructor
for intervals that just  gives us

216
00:17:24,013 --> 00:17:28,845
an interval with these two As as
lower and upper bound included.

217
00:17:29,715 --> 00:17:33,075
Then we have from and to, to
construct an interval that starts

218
00:17:33,075 --> 00:17:35,865
at A and last until eternity.

219
00:17:36,495 --> 00:17:41,895
And to, the opposite an interval
that stops at A, then always is the

220
00:17:41,975 --> 00:17:46,754
interval that is used by default,
that includes all times, never is

221
00:17:46,754 --> 00:17:51,165
the empty interval, singleton is an
interval that only contains this one A.

222
00:17:52,545 --> 00:17:56,784
Hull is the smallest interval that
contains the two given intervals.

223
00:17:57,284 --> 00:18:00,524
Intersection as the name suggests
intersects two intervals, the

224
00:18:00,524 --> 00:18:02,114
result will again be an interval.

225
00:18:03,495 --> 00:18:09,254
Overlaps checks whether two
intervals have an element in common.

226
00:18:10,604 --> 00:18:16,334
Contains checks whether one interval
is contained in the other, so we

227
00:18:16,334 --> 00:18:21,254
must just check which will round,
so I think the second one must

228
00:18:21,254 --> 00:18:23,594
be included in the first one.

229
00:18:25,185 --> 00:18:27,495
Is empty checks whether
an interval is empty.

230
00:18:27,975 --> 00:18:33,645
Before checks whether the given time
is before everything in this interval.

231
00:18:34,304 --> 00:18:38,114
After the opposite, whether the given
time is after everything in this interval.

232
00:18:40,245 --> 00:18:46,110
These are just convenience functions to
construct strict lower and upper bounds.

233
00:18:47,370 --> 00:18:51,680
We can play with intervals a
bit, so let's start a repl.

234
00:18:54,890 --> 00:19:02,150
And let's import Plutus
V1 ledger interval.

235
00:19:04,070 --> 00:19:08,330
Now, for example, we can use this
interval smart constructor and

236
00:19:08,330 --> 00:19:13,010
as A let's just use integers for
simplicity, so for example, the

237
00:19:13,080 --> 00:19:19,070
interval between 10 and 20, let me see.

238
00:19:19,070 --> 00:19:24,170
Okay, it says the lower bound is
finite 10, 10 is included, the upper

239
00:19:24,170 --> 00:19:26,630
bound is finite 20, 20 is included.

240
00:19:27,360 --> 00:19:34,910
So for example, we can now check
with member whether nine is a

241
00:19:34,910 --> 00:19:37,450
member of this interval, it's not.

242
00:19:38,629 --> 00:19:39,720
But 10 should be.

243
00:19:41,340 --> 00:19:41,970
It is.

244
00:19:42,360 --> 00:19:50,639
So it should be 12 and
20, but 21 shouldn't.

245
00:19:52,970 --> 00:20:09,139
Or let's use the from, so we have from 30,
21 is not included in that, 30 should be.

246
00:20:10,220 --> 00:20:12,770
And now everything larger
than 30 should also be.

247
00:20:14,689 --> 00:20:17,480
Right, and to, let's try the to.

248
00:20:21,270 --> 00:20:26,220
So 31 still shouldn't be included.

249
00:20:27,149 --> 00:20:32,270
30 should be, and everything
lower than 30 as well.

250
00:20:33,870 --> 00:20:35,729
Okay, so that seems to work.

251
00:20:35,790 --> 00:20:47,850
Let's try one more thing, maybe the
intersection, so let's intersect this

252
00:20:47,850 --> 00:20:57,000
one from 10 to 20 with the one from,
I don't know, 18 to 30 and as expected

253
00:20:57,030 --> 00:20:59,909
we get the interval from 18 to 20.

254
00:21:00,959 --> 00:21:04,139
Let's also try the
contains and the overlap.

255
00:21:04,800 --> 00:21:19,820
So for example, contains
to 100 interval 30 80.

256
00:21:21,230 --> 00:21:21,639
True.

257
00:21:21,720 --> 00:21:22,650
So what does that mean?

258
00:21:22,650 --> 00:21:27,660
That means the interval that starts at
30 and ends at 80 is contained, fully

259
00:21:27,660 --> 00:21:33,120
contained in the interval that starts at
the beginning of time and goes to 100.

260
00:21:33,840 --> 00:21:38,910
If you now change this 80 to 100
should still be true, but if you

261
00:21:38,910 --> 00:21:41,610
change it to 101, it's no longer true.

262
00:21:43,170 --> 00:21:57,300
But if we check overlaps, then it is
true because for example, 40 is contained

263
00:21:57,300 --> 00:21:59,250
in this interval and also in that one.

264
00:22:00,720 --> 00:22:05,790
So overlaps is true, but contains is false
because the second interval is not fully

265
00:22:05,790 --> 00:22:11,010
contained in the first one, the 101 is in
the second one, but not in the first one.

266
00:22:12,450 --> 00:22:19,800
If we, however, use
something like 101 to 110.

267
00:22:21,330 --> 00:22:23,670
Then it's false, then it
don't overlap any longer.

268
00:22:25,080 --> 00:22:30,010
So now let's look at an example
for using this time range.

269
00:22:33,040 --> 00:22:37,660
One of my colleagues at
input output bought some ADA

270
00:22:37,690 --> 00:22:40,240
for his nephews and nieces.

271
00:22:40,750 --> 00:22:46,120
And of course, I don't know any details
about that, but just imagine you want

272
00:22:46,120 --> 00:22:49,570
to make a gift of ADA to a child.

273
00:22:50,230 --> 00:22:56,470
So you want the child to own the
ADA, but you only want the child

274
00:22:56,470 --> 00:23:01,770
to have access to the ADA when he,
or she turns 18 or 21 or whatever.

275
00:23:02,880 --> 00:23:08,830
And using Plutus, this is a very
easy to implement a scheme like

276
00:23:08,830 --> 00:23:10,510
that, a vesting scheme like that.

277
00:23:10,960 --> 00:23:18,284
So I copied the is data contract and Into
a new module that are called vesting.

278
00:23:19,064 --> 00:23:25,995
And as our first example of validator
that actually uses the context.

279
00:23:26,294 --> 00:23:30,284
I want to try to implement
this vesting idea.

280
00:23:31,064 --> 00:23:35,955
So you put money into a script
and only the dedicated person

281
00:23:35,955 --> 00:23:40,185
can retrieve it, but only once a
certain deadline has been reached.

282
00:23:41,595 --> 00:23:47,475
So the first step is to think about
the types of datum and redeemer.

283
00:23:48,165 --> 00:23:52,905
And the datum, I think in this
case, it makes sense to have exactly

284
00:23:52,905 --> 00:23:57,794
these two pieces of information,
the beneficiary and the deadline.

285
00:23:57,865 --> 00:24:03,254
So let's define this type,
let's call it vesting datum.

286
00:24:04,034 --> 00:24:14,455
Let's make it a record type with those
two fields, beneficiary of type, well...

287
00:24:15,044 --> 00:24:22,004
How do we identify the beneficiary
by his or her public key or to

288
00:24:22,004 --> 00:24:23,705
be more precise, public key hash.

289
00:24:25,095 --> 00:24:30,435
And then we need the deadline
that will be of type POSIX time.

290
00:24:33,185 --> 00:24:39,605
We can derive a show instance, might
be useful for debugging, we don't

291
00:24:39,605 --> 00:24:41,855
need the my silly redeemer anymore.

292
00:24:43,145 --> 00:24:47,195
But we do need an is data
instance of our vesting datum.

293
00:24:51,495 --> 00:24:55,695
Right, so the first argument is the datum.

294
00:24:55,725 --> 00:24:58,305
So that's now of type vesting datum.

295
00:24:59,264 --> 00:25:01,905
So for redeemer, do we need any
information in the redeemer?

296
00:25:02,325 --> 00:25:05,745
What do we need in order to check
whether a transaction is allowed

297
00:25:05,805 --> 00:25:10,065
to spent this script output.

298
00:25:10,435 --> 00:25:16,335
We need to know that it has been signed
by the beneficiary and we must know that

299
00:25:16,365 --> 00:25:21,135
it's only submitted after the deadline,
but those two pieces of information are

300
00:25:21,135 --> 00:25:23,175
both contained in the transaction itself.

301
00:25:23,625 --> 00:25:27,044
So we don't need anything in
addition to that in the redeemer.

302
00:25:27,044 --> 00:25:31,274
So we can just use unit for the redeemer.

303
00:25:33,345 --> 00:25:35,715
So first argument now we need it.

304
00:25:35,935 --> 00:25:38,534
so, let's call it dat for datum.

305
00:25:41,415 --> 00:25:47,595
So the redeemer is just unit, and now
we can't any longer ignore the context.

306
00:25:48,435 --> 00:25:52,335
So let's give it a name, right?

307
00:25:52,335 --> 00:25:54,254
So now we need to check two conditions.

308
00:25:54,615 --> 00:26:01,044
That the transaction is signed
by the beneficiary and that, it

309
00:26:01,865 --> 00:26:05,529
has been submitted or that the
current time is after the deadline.

310
00:26:06,649 --> 00:26:14,129
So let's delegate the helper functions,
let's just write the general structure.

311
00:26:15,120 --> 00:26:22,860
So let's say beneficiary's
signature missing.

312
00:26:22,860 --> 00:26:29,909
So this is the error message we get
in case it's false and let's call it

313
00:26:29,909 --> 00:26:37,129
something like signed by beneficiary.

314
00:26:38,459 --> 00:26:45,419
And so we need the second condition
that the deadline has been reached.

315
00:26:45,719 --> 00:26:56,840
So dead line not reached, let's
call that, deadline reached.

316
00:26:58,800 --> 00:26:59,070
Okay.

317
00:26:59,070 --> 00:27:02,280
Now, of course these two signed
by beneficiary and deadline

318
00:27:02,280 --> 00:27:04,140
reached be must defined.

319
00:27:06,120 --> 00:27:08,760
And for both, we will need this Tx info.

320
00:27:09,720 --> 00:27:13,170
So let's first define
that, of type Tx info.

321
00:27:17,560 --> 00:27:25,600
And that, I am here in the repl and
I imported ledger and asked for the

322
00:27:26,320 --> 00:27:28,030
information on the script context again.

323
00:27:28,390 --> 00:27:31,840
So in order to get the Tx info from
the script in context, we must use

324
00:27:31,840 --> 00:27:34,360
this field name script context Tx info.

325
00:27:35,050 --> 00:27:43,240
So that script context TX info
of our context, now we can

326
00:27:43,360 --> 00:27:45,250
define the two conditions.

327
00:27:45,250 --> 00:27:49,870
Let's first do the signed
by beneficiary of type bool.

328
00:27:52,060 --> 00:27:52,390
Okay.

329
00:27:52,390 --> 00:27:53,620
How do we check that?

330
00:27:58,725 --> 00:28:04,515
Well, if we check in the repl again
there's a function called Tx signed by

331
00:28:04,915 --> 00:28:09,645
the takes a Tx info, which we now have
and the pub key hash, and then says

332
00:28:09,645 --> 00:28:15,285
whether that transaction that had Tx info
has been signed by this public key hash.

333
00:28:15,345 --> 00:28:16,335
So we can use that.

334
00:28:17,955 --> 00:28:25,945
Tx signed by info, which I just
defined and now we need the public key

335
00:28:25,945 --> 00:28:31,534
hash of the beneficiary and that we
have, because we have the datum, dat.

336
00:28:31,885 --> 00:28:35,615
And this is of type vesting datum
and we have the beneficiary there,

337
00:28:35,675 --> 00:28:38,885
so I can do beneficiary of that.

338
00:28:40,025 --> 00:28:41,255
So that's our first condition.

339
00:28:42,155 --> 00:28:47,115
And the second condition, deadline
reached, was of type bool.

340
00:28:50,585 --> 00:28:52,100
So how do we check that?

341
00:28:52,220 --> 00:28:56,149
So if we look at this crew diagram,
so this is time, and let's say

342
00:28:56,149 --> 00:29:00,860
the deadline is here and let's
consider a transaction with, let's

343
00:29:00,860 --> 00:29:03,190
first say this validity interval.

344
00:29:04,310 --> 00:29:10,040
So recall what that means before
the validator script is run.

345
00:29:11,090 --> 00:29:13,310
Other checks are made
including the time check.

346
00:29:13,340 --> 00:29:18,020
So the node checks whether the
current time falls into the valid

347
00:29:18,020 --> 00:29:22,340
range of the transaction and
only then it's the validator run.

348
00:29:22,730 --> 00:29:26,790
So we know now that we are in the
validator, the current time lives

349
00:29:26,810 --> 00:29:28,610
somewhere in the validity interval.

350
00:29:29,149 --> 00:29:32,419
But if this here, the first one
would be the validity interval,

351
00:29:32,600 --> 00:29:36,379
then the current time could be for
example, here, which would be fine.

352
00:29:36,379 --> 00:29:39,560
It would be after the deadline,
but it could also be here,

353
00:29:39,620 --> 00:29:40,730
which would not be fine.

354
00:29:40,730 --> 00:29:41,899
It would be before the deadline.

355
00:29:41,899 --> 00:29:44,480
So this validity interval
is no good for us.

356
00:29:45,254 --> 00:29:48,945
We mustn't declare the
transaction to be valid.

357
00:29:48,975 --> 00:29:50,495
If this is the validity interval.

358
00:29:51,074 --> 00:29:54,135
This one, the other hand is fine, we
still don't know where the current

359
00:29:54,135 --> 00:29:57,975
time exactly is, it can be anywhere
in this interval, but no matter

360
00:29:57,975 --> 00:30:00,044
where it is, it's after the deadline.

361
00:30:00,615 --> 00:30:04,365
So we must check that we have this
situation that the whole interval

362
00:30:04,365 --> 00:30:06,165
is to the right of the deadline.

363
00:30:06,675 --> 00:30:11,615
And one way to do is to use this contains
function that you played with earlier.

364
00:30:12,645 --> 00:30:16,695
And look at this interval, the half
open interval that starts at the

365
00:30:16,695 --> 00:30:18,645
deadline and stretches into infinity.

366
00:30:18,975 --> 00:30:23,264
And if this interval contains
the validity interval of the

367
00:30:23,264 --> 00:30:24,405
transaction, then we are good.

368
00:30:25,095 --> 00:30:29,254
Then we know no matter where the current
time is, it will be after the deadline.

369
00:30:32,074 --> 00:30:34,085
So we can use contains.

370
00:30:35,345 --> 00:30:41,915
Now the interval starting at
the deadline is from, and the

371
00:30:41,915 --> 00:30:44,435
deadline we can get from the datum.

372
00:30:46,695 --> 00:30:52,095
And now we need the validity interval
of the transaction and that if we look

373
00:30:52,095 --> 00:30:58,815
here at the information of the Tx info,
then this was called Tx info valid range

374
00:31:02,765 --> 00:31:06,325
of the info, and that should be it.

375
00:31:08,275 --> 00:31:13,865
Next let's look at this dummy typed
that wraps up datum and redeemer type.

376
00:31:14,655 --> 00:31:16,255
Typed is not a good name.

377
00:31:17,165 --> 00:31:25,435
Let's call it vesting and the
datum type is now our vesting

378
00:31:25,435 --> 00:31:30,665
datum type and the of our vesting.

379
00:31:34,355 --> 00:31:36,105
And the redeemer type it's just unit.

380
00:31:37,305 --> 00:31:40,455
Okay, this is just boiler plate.

381
00:31:43,315 --> 00:31:44,995
We must just put the right types here.

382
00:31:45,025 --> 00:31:52,105
So vesting, datum and
unit, that should be fine.

383
00:31:55,095 --> 00:31:59,035
Now, of course we also have to
change the off-chain part, but as

384
00:31:59,035 --> 00:32:02,995
before, because the focus of this
lecture is on-chain validation.

385
00:32:03,535 --> 00:32:07,795
I already prepared that and
we just briefly go through it.

386
00:32:07,885 --> 00:32:13,705
And I should also mention that at the top
of the module, I added some additional

387
00:32:14,215 --> 00:32:20,995
GHC extensions, like derive any class and
derive generic and also added some imports

388
00:32:21,045 --> 00:32:24,915
like to json, from json generic and so on.

389
00:32:27,045 --> 00:32:29,555
So let's briefly look
at the off-chain part.

390
00:32:30,095 --> 00:32:34,755
So, this type here, vesting
schema defines the endpoints that

391
00:32:34,755 --> 00:32:36,645
we want to expose to the user.

392
00:32:37,215 --> 00:32:44,274
And as before in our silly example
from last week call the give and grab.

393
00:32:44,314 --> 00:32:49,995
So give is for the person that wants to
set up this vesting contract and then

394
00:32:49,995 --> 00:32:52,215
grab for the beneficiary to collect.

395
00:32:53,235 --> 00:32:55,205
So what parameters do we need?

396
00:32:56,345 --> 00:33:02,445
For give, I mean, what this endpoint
will do is it will create a UTxO

397
00:33:02,465 --> 00:33:08,695
at the vesting address with the
specified amount and the correct datum.

398
00:33:08,825 --> 00:33:13,265
And if you recall our vesting datum
contains the beneficiary and the deadline.

399
00:33:13,895 --> 00:33:17,585
So this give endpoint must
in particular know those, the

400
00:33:17,645 --> 00:33:19,085
beneficiary and the deadline.

401
00:33:19,325 --> 00:33:24,215
So this is here and we also of course,
have to specify how much money we

402
00:33:24,215 --> 00:33:28,085
want to put at this UTxO, therefore
I need a third field, the amount.

403
00:33:30,084 --> 00:33:36,415
The grab endpoint on the other hand,
doesn't need any parameters because the

404
00:33:37,195 --> 00:33:44,485
beneficiary will just look for UTxOs
sitting at the vesting address and then

405
00:33:44,485 --> 00:33:47,304
can check whether he is the beneficiary.

406
00:33:47,784 --> 00:33:51,715
And whether the deadline has
already passed and can then pick

407
00:33:51,715 --> 00:33:55,225
those UTxOs and consume them.

408
00:33:55,915 --> 00:33:59,824
And we know from the way that we've
wrote the validator, that will

409
00:33:59,844 --> 00:34:03,955
then succeed and no additional
information has to be supplied.

410
00:34:04,495 --> 00:34:07,465
Let's briefly look at the
endpoints, first at give.

411
00:34:08,214 --> 00:34:13,889
So it takes the give parameters and
first I compute the datum I want to use.

412
00:34:14,069 --> 00:34:17,759
So recall I need the beneficiary and
the deadline, then I can get those

413
00:34:18,509 --> 00:34:24,400
simply from reading it from the give
parameters now for the transaction.

414
00:34:25,409 --> 00:34:28,949
I need as constraint that I want
to create a transaction that has

415
00:34:28,949 --> 00:34:30,960
an output at this script address.

416
00:34:31,230 --> 00:34:35,750
That's why I use this must pay to the
script with the data, my justified,

417
00:34:36,210 --> 00:34:37,679
and then I must provide the value.

418
00:34:38,040 --> 00:34:43,679
So I take the value, the amount
from the give parameters, and then

419
00:34:43,679 --> 00:34:47,449
use this function here to convert
that to a value in lovelace.

420
00:34:48,659 --> 00:34:52,020
The rest is as before I just
changed the log message.

421
00:34:52,409 --> 00:34:58,170
So I mention the amount, the
beneficiary and the deadline.

422
00:35:00,370 --> 00:35:04,180
Now for the grab, that's a bit
more involved because there can be

423
00:35:04,180 --> 00:35:06,820
many UTxOs at this vesting address.

424
00:35:07,270 --> 00:35:11,290
And some of them might not be
suitable for me, either because I

425
00:35:11,290 --> 00:35:15,190
am not the beneficiary or because
the deadline has not yet passed.

426
00:35:15,850 --> 00:35:22,150
So I grab the current time, I lookup
my own public key and computes hash,

427
00:35:23,140 --> 00:35:28,360
and then I look at all UTxOs sitting
at the script address, but I filter

428
00:35:28,360 --> 00:35:31,029
those and the filter is defined here.

429
00:35:31,060 --> 00:35:40,630
So I get such a UTxO and then I
first check the datum hash whether.

430
00:35:48,600 --> 00:35:55,995
So I first check the datum hash and
if I find it it's this H, then I try

431
00:35:55,995 --> 00:36:01,995
to lookup the corresponding datum
and recall what I said several times

432
00:36:01,995 --> 00:36:04,694
before, the producing transaction.

433
00:36:04,705 --> 00:36:09,845
So in our case, the one that has been
produced by the give endpoint, doesn't

434
00:36:09,845 --> 00:36:11,754
necessarily have to contain the datum.

435
00:36:11,834 --> 00:36:16,575
It can all only contain the datum
hash, but if that was the case, then

436
00:36:16,575 --> 00:36:21,705
I would have a problem here in grab, I
wouldn't be able to find the datum that

437
00:36:21,705 --> 00:36:23,834
corresponds to the UTxO that I find.

438
00:36:24,314 --> 00:36:31,515
But by using this must pay to the script
constraint, I make use of the option to

439
00:36:31,515 --> 00:36:33,464
include the datum into the transaction.

440
00:36:33,825 --> 00:36:37,615
So this transaction will actually
optionally contain the datum.

441
00:36:37,634 --> 00:36:42,645
So it will contain the datum and
that's why I should be able to

442
00:36:43,365 --> 00:36:44,865
find it here, look at up here.

443
00:36:45,765 --> 00:36:49,754
So I have this datum and
then I must deserialize it.

444
00:36:49,814 --> 00:36:55,125
So this is of the data type, but
I want the vesting datum type.

445
00:36:55,145 --> 00:36:56,055
So that's the last step.

446
00:36:56,715 --> 00:37:02,745
So if all of this succeeds, then I
can check whether the beneficiary of

447
00:37:02,745 --> 00:37:08,145
the datum is myself and whether the
deadline doesn't lie in the future.

448
00:37:09,195 --> 00:37:14,265
So at this point the UTxOs are only
UTxOs sitting at this vesting address

449
00:37:15,255 --> 00:37:19,605
where I am the beneficiary and
where the deadline has been reached.

450
00:37:21,135 --> 00:37:27,795
And if I find no such UTxOs I
just log a message that nothing is

451
00:37:27,795 --> 00:37:29,535
available and don't do anything else.

452
00:37:30,555 --> 00:37:36,765
And if there's at least one, then I
construct one transaction that consumes

453
00:37:36,795 --> 00:37:42,480
all of them as inputs and paste the
money in there, to my own wallet.

454
00:37:43,210 --> 00:37:47,509
So, I have to as look-ups provide
these UTxOs, and I also have to

455
00:37:47,509 --> 00:37:49,610
provide the validator script.

456
00:37:50,250 --> 00:37:55,069
Recall, if a transaction wants to spend
a UTxO sitting at the script address.

457
00:37:55,549 --> 00:37:58,940
The script must be provided
by this spending transaction.

458
00:37:59,000 --> 00:38:00,799
So this lookup here takes care of that.

459
00:38:01,790 --> 00:38:07,220
And this here I basically just
go over the list of all UTxOs and

460
00:38:07,220 --> 00:38:08,750
say "I want to spend that one".

461
00:38:10,130 --> 00:38:17,850
And as I said, by default, the time
range of a transaction will be this

462
00:38:17,880 --> 00:38:22,430
always, the time range it start
and Genesis and goes on forever.

463
00:38:23,120 --> 00:38:24,920
So if I don't do anything,
I would use that.

464
00:38:24,920 --> 00:38:27,860
And that wouldn't be good because
then validation would fail

465
00:38:27,890 --> 00:38:31,750
because recall validation checks
that the deadline has passed.

466
00:38:31,930 --> 00:38:37,140
And It only knows that the current
time lives in this validity interval.

467
00:38:37,190 --> 00:38:40,370
So if the validity interval is
from the beginning of time, to the

468
00:38:40,370 --> 00:38:44,390
end of time, I have no information
and then I wouldn't be able to be

469
00:38:44,390 --> 00:38:45,830
sure that the deadline has passed.

470
00:38:46,250 --> 00:38:49,280
So I must provide the different
validity interval that I can do with

471
00:38:49,280 --> 00:38:52,110
this must validate in constraint.

472
00:38:52,800 --> 00:39:00,280
And here I picked from now, it's just
important that everything interval that

473
00:39:00,280 --> 00:39:02,110
I provide here is after the deadline.

474
00:39:02,720 --> 00:39:07,630
But so I could, for example, just
use the Singleton interval now, but

475
00:39:07,660 --> 00:39:11,830
then I would have a problem if the
transaction doesn't get there in the

476
00:39:11,830 --> 00:39:15,100
same slot to the node for validation.

477
00:39:15,700 --> 00:39:21,490
So if it only reaches their slot later,
then the current time at that point

478
00:39:21,490 --> 00:39:26,050
would already not be in this interval
anymore, which only contains now.

479
00:39:26,920 --> 00:39:29,800
So the best is to make
it as large as possible.

480
00:39:29,800 --> 00:39:37,330
So I started now, but then get it last
into eternity and the rest is same as

481
00:39:37,330 --> 00:39:45,760
before, and then I just bundled them
up in this endpoints contract and

482
00:39:45,760 --> 00:39:47,230
some boiler plate for the playground.

483
00:39:48,370 --> 00:39:50,140
Let's try it in the playground.

484
00:39:51,310 --> 00:39:56,620
So we see that the playground
has changed earlier.

485
00:39:56,710 --> 00:40:02,590
Last week, we saw that the default
amount was 10 lovelace, which is too low.

486
00:40:03,940 --> 00:40:08,790
Because fees are now included and the
fees are normally higher than 10 lovelace.

487
00:40:08,950 --> 00:40:12,310
So this default was no longer adequate.

488
00:40:12,700 --> 00:40:14,310
So now it's, what is it?

489
00:40:14,649 --> 00:40:18,759
100 ADA is the default value.

490
00:40:19,779 --> 00:40:26,500
So let's add a third wallet and
I want wallet one to make gifts

491
00:40:26,500 --> 00:40:27,910
to wallet two and wallet three.

492
00:40:30,640 --> 00:40:31,029
Okay.

493
00:40:31,120 --> 00:40:39,720
So wallet one starts, makes a gift and
normally it will be possible to submit all

494
00:40:39,720 --> 00:40:42,240
three give transactions in the same slot.

495
00:40:43,140 --> 00:40:46,830
So I wouldn't need a wait action,
but the way I implemented it, the

496
00:40:46,830 --> 00:40:51,480
give endpoint after submitting the
transaction, I wait for confirmation.

497
00:40:52,590 --> 00:40:55,410
Maybe I shouldn't have done
that, but it is what it is.

498
00:40:55,950 --> 00:41:01,605
And that means we, before this
give endpoint returns, the

499
00:41:02,055 --> 00:41:04,395
transaction must be confirmed.

500
00:41:04,695 --> 00:41:05,865
So we do have to wait.

501
00:41:07,395 --> 00:41:11,625
So let's wait one block.

502
00:41:12,975 --> 00:41:16,545
And the second give,
let's wait another block.

503
00:41:18,555 --> 00:41:19,714
In the third give.

504
00:41:23,505 --> 00:41:25,515
Oh, okay.

505
00:41:26,205 --> 00:41:30,795
So the idea is wallet one makes two
gives to wallet two with different

506
00:41:30,795 --> 00:41:32,565
deadlines and one give to wallet three.

507
00:41:33,645 --> 00:41:36,705
So now we have our first problem.

508
00:41:37,185 --> 00:41:40,845
What is the public key hash of
wallet two and of wallet three?

509
00:41:41,295 --> 00:41:44,175
There is a way to find out what it is.

510
00:41:44,175 --> 00:41:46,455
So let's switch to the repl.

511
00:41:48,105 --> 00:41:57,975
Let's load our module, let's import
ledger and let's import Wallet.Emulator.

512
00:41:59,715 --> 00:42:05,685
Now, first of all, we have a wallet
type and we see wallet it's just

513
00:42:05,685 --> 00:42:07,505
a newtype wrap around integer.

514
00:42:09,495 --> 00:42:15,495
Secondly, we have something
called wallet pub key, given

515
00:42:15,495 --> 00:42:16,785
a wallet gives us a pub key.

516
00:42:16,995 --> 00:42:24,715
And finally, we have pub key hash, given
a pub key gives us the pub key hash.

517
00:42:24,845 --> 00:42:33,265
So, putting all of these together,
we can do pub key hash of

518
00:42:34,125 --> 00:42:39,095
wallet pub key of wallet two.

519
00:42:40,215 --> 00:42:42,525
And there we have the
hash and wallet three.

520
00:42:43,545 --> 00:42:49,395
So let's grab the pub key hash
of wallet two and let's put

521
00:42:49,395 --> 00:42:51,665
it in the first two gives.

522
00:42:53,505 --> 00:42:55,885
Let's grab the pub key
hash of wallet three.

523
00:42:56,945 --> 00:42:58,785
And put it in the third give.

524
00:43:01,925 --> 00:43:03,905
Next problem is the deadline.

525
00:43:05,345 --> 00:43:09,665
In last lecture, I showed you
how to convert between slots

526
00:43:09,695 --> 00:43:12,215
and deadlines or POSIX times.

527
00:43:12,995 --> 00:43:15,905
But unfortunately, this has
changed in the meantime.

528
00:43:16,325 --> 00:43:19,835
So back then you just needed a
slot and out came a POSIX time.

529
00:43:20,135 --> 00:43:21,665
Now there's a second argument.

530
00:43:22,655 --> 00:43:30,305
If you go back to the repl and import
ledger time slot, then there's a

531
00:43:30,305 --> 00:43:36,605
function slot to begin, begin POSIX time.

532
00:43:38,165 --> 00:43:43,895
And this now takes a slot config and the
slot to give us a POSIX time, by the way,

533
00:43:43,895 --> 00:43:46,445
there are versions with begin and end.

534
00:43:47,165 --> 00:43:51,029
This is because a slot has,
it's not just a point in time.

535
00:43:51,029 --> 00:43:52,890
It's, it's a duration in time.

536
00:43:53,340 --> 00:43:57,240
So it has a beginning and an
end, so these two are for that,

537
00:43:57,900 --> 00:43:59,400
so what's this lot config?

538
00:44:01,020 --> 00:44:04,320
That contains the slot length
and the zero slot time.

539
00:44:04,330 --> 00:44:07,650
So that POSIX time at
which sc zero starts.

540
00:44:08,730 --> 00:44:12,420
So now we have to find out what slot
config to use for the playground.

541
00:44:12,450 --> 00:44:15,090
Luckily it's the default slot config.

542
00:44:15,270 --> 00:44:17,300
So what's the default slot config?

543
00:44:17,970 --> 00:44:23,810
For that we need to import yet
another module, Data.Default.

544
00:44:24,540 --> 00:44:28,999
And that defines a class called
default, lots of instances.

545
00:44:30,519 --> 00:44:35,960
And we see a def method of type A.

546
00:44:35,960 --> 00:44:41,900
So if a type A implement, is an
instance of class default, then by

547
00:44:41,900 --> 00:44:46,370
using def we get an A, so the idea is
that, that is then the default value.

548
00:44:47,060 --> 00:44:55,445
And if you check slot config again, then
now that we imported Data.Default, we

549
00:44:55,445 --> 00:44:57,875
see it is indeed an instance of default.

550
00:44:57,995 --> 00:45:03,245
So by using def and telling the
compiler what type we're interested

551
00:45:03,245 --> 00:45:06,215
in, we get the default slot config.

552
00:45:06,395 --> 00:45:08,754
So we see slot length is 1000.

553
00:45:09,134 --> 00:45:12,695
So that means POSIX time is
obviously in milliseconds.

554
00:45:12,695 --> 00:45:18,195
So the 1000 is one second and we see
when in the playground slot zero starts.

555
00:45:19,325 --> 00:45:30,845
So now we can use the slot to begin POSIX
time and can use def as our slot config.

556
00:45:31,175 --> 00:45:37,145
And now we can, for example, see what
POSIX time slot 10 begins and slot 20.

557
00:45:38,134 --> 00:45:41,735
So let's take the POSIX time for slot 10.

558
00:45:43,665 --> 00:45:50,725
Let's say the first give to wallet
two has a deadline of 10 and the give

559
00:45:50,775 --> 00:45:52,634
to wallet three has a deadline of 10.

560
00:45:53,955 --> 00:46:00,735
And to take the POSIX time for
20 and say the second give to

561
00:46:00,735 --> 00:46:05,055
wallet two has deadline 20.

562
00:46:06,375 --> 00:46:13,485
Now let's add the amount,
let's say 10 ADA each.

563
00:46:17,235 --> 00:46:17,685
Okay.

564
00:46:17,715 --> 00:46:22,425
And now let's first check the scenario
where everything works perfectly.

565
00:46:22,575 --> 00:46:28,925
So let's say wallet three grabs at
slot 10 when the deadline for wallet

566
00:46:28,945 --> 00:46:35,225
three has passed, don't need any
parameters or arguments for grab.

567
00:46:36,465 --> 00:46:37,854
And let's say that...

568
00:46:38,395 --> 00:46:44,205
Oh, it's wait until not wait for
and here as well wait until slot 20.

569
00:46:44,845 --> 00:46:48,034
And now wallet two grabs.

570
00:46:49,124 --> 00:46:52,115
So both give to wallet two at
that point should be available.

571
00:46:52,685 --> 00:47:00,965
And finally, we'll wait one more block
for giving it a chance to process and

572
00:47:00,965 --> 00:47:02,945
end up on the blockchain and evaluate.

573
00:47:05,405 --> 00:47:08,515
Okay, let's look at the transactions.

574
00:47:08,515 --> 00:47:13,415
So as always slot zero first one
is the Genesis transaction that

575
00:47:13,475 --> 00:47:15,125
distributes the initial funds.

576
00:47:15,215 --> 00:47:18,155
So wallet 2, 1, 3, all get a hundred ADA.

577
00:47:19,865 --> 00:47:26,455
Slot one is the gift from wallet
one to wallet two with deadline 10.

578
00:47:27,805 --> 00:47:34,765
So we see almost 90 ADA changed
go back to wallet one and 10 are

579
00:47:34,765 --> 00:47:36,565
locked by the script address.

580
00:47:37,765 --> 00:47:42,265
So the second one is the give
to wallet two with deadline 20.

581
00:47:43,425 --> 00:47:49,695
So now the change is 80, so wallet
one has 80 left, another 10 go

582
00:47:49,695 --> 00:47:53,475
into a different UTxO in the
script, at that script address.

583
00:47:54,045 --> 00:47:55,455
Finally, the third gift.

584
00:47:55,875 --> 00:48:01,935
Now wallet one ends up with
70 and another 10 go into a

585
00:48:01,935 --> 00:48:04,425
third UTxO at the same address.

586
00:48:05,895 --> 00:48:10,995
Now in slot 10, this is now where
three grabs and that succeeds.

587
00:48:11,025 --> 00:48:16,305
So the third UTxO is the input, is spent.

588
00:48:17,415 --> 00:48:22,755
Some fees are paid and wallet
three ends up with roughly 10 ADA.

589
00:48:23,505 --> 00:48:30,635
Finally slot 20, wallet two picks up
the two UTxOs that were for wallet two,

590
00:48:31,545 --> 00:48:34,485
both deadlines have passed at 10 and 20.

591
00:48:35,505 --> 00:48:41,055
Some fees paid roughly twice
because now two validators have

592
00:48:41,055 --> 00:48:43,305
to run for each script input.

593
00:48:44,895 --> 00:48:48,185
And wallet two ends up
with roughly 20 ADA.

594
00:48:49,335 --> 00:48:54,525
And the final balances should
reflect that, that wallet one has

595
00:48:54,525 --> 00:49:01,015
70 left, wallet two has roughly
1.20, wallet one has roughly 1.10,

596
00:49:02,055 --> 00:49:03,705
so that all works as expected.

597
00:49:04,635 --> 00:49:09,055
Let's try what happens if
wallet two doesn't grab at

598
00:49:09,075 --> 00:49:11,295
slot 20, but only at slot 15.

599
00:49:19,045 --> 00:49:19,555
Okay.

600
00:49:20,005 --> 00:49:25,085
So the first transaction should be the
same and now the transaction slot 15, only

601
00:49:25,105 --> 00:49:29,785
one input because the second UTxO, the
one with deadline 20 is not yet available.

602
00:49:30,355 --> 00:49:34,345
So only one input and wallet
two only ends up with 10.

603
00:49:35,125 --> 00:49:41,340
And we see that still 10 are still
locked at the script address.

604
00:49:42,240 --> 00:49:46,560
So those can only be claimed
by wallet two after slot 20.

605
00:49:49,710 --> 00:49:53,930
There's one thing I should point out
that I've wrote the off-chain code, the

606
00:49:53,940 --> 00:49:58,980
wallet code in a way that only submits
a transaction, if it can actually

607
00:49:59,400 --> 00:50:04,680
grab the UTxO, if you recall, I filled
out the UTxO to check that, I am the

608
00:50:04,680 --> 00:50:07,590
beneficiary and the deadline has passed.

609
00:50:08,550 --> 00:50:13,440
Which means that we don't really exercise
the validator because we only send

610
00:50:14,090 --> 00:50:21,310
transactions to the blockchain that then
get validated, that will pass validation.

611
00:50:21,520 --> 00:50:23,410
That's how we wrote the wallet code.

612
00:50:24,160 --> 00:50:27,280
So if you want to actually
test the validator, you would

613
00:50:27,280 --> 00:50:28,750
have to modify the wallet code.

614
00:50:28,750 --> 00:50:30,980
If you like, you can do
that as an option homework.

615
00:50:31,000 --> 00:50:37,990
So remove these checks in the wallet
and just try to grab everything, and

616
00:50:37,990 --> 00:50:42,980
then it should fail if you are not
the beneficiary or if the deadline

617
00:50:43,000 --> 00:50:46,810
has not yet been reached and then
it should fail you in validation,

618
00:50:46,810 --> 00:50:51,730
not already just in the wallet, not
even submitting the transaction.

619
00:50:54,490 --> 00:50:56,950
So you always have to be
careful or keep that in mind.

620
00:50:58,030 --> 00:51:00,130
Everybody of course can
write off-chain code.

621
00:51:00,940 --> 00:51:06,600
So, even though now it works as long as
you use the grab endpoint that I provided.

622
00:51:06,779 --> 00:51:11,279
I mean, I wrote it in a way that you
never try to claim something that's

623
00:51:11,279 --> 00:51:15,120
not for you, but of course, somebody
else could write different piece of

624
00:51:15,270 --> 00:51:17,459
off-chain code that doesn't try that.

625
00:51:17,459 --> 00:51:21,990
And then if your validator is not
correct, if it for example, forgets to

626
00:51:21,990 --> 00:51:25,560
check the beneficiary or the deadline,
then something could go horribly wrong.

627
00:51:26,910 --> 00:51:31,399
So we must keep that in mind that only
because it works for the endpoints

628
00:51:31,830 --> 00:51:35,759
you have provided doesn't mean that
somebody else couldn't come up with

629
00:51:35,819 --> 00:51:37,529
other endpoints where it doesn't work.

630
00:51:39,509 --> 00:51:39,779
Okay.

631
00:51:39,779 --> 00:51:45,089
So this is the vesting example where
we made use of the context for the

632
00:51:45,089 --> 00:51:50,939
first time and where we made use
of this valid time interval in the

633
00:51:50,939 --> 00:51:53,529
transaction to implement a deadline.

634
00:51:54,759 --> 00:52:00,410
I copied the code of the vesting module
into a new model called parameterized.

635
00:52:01,640 --> 00:52:05,360
And I want to talk about
parameterized contracts next.

636
00:52:06,110 --> 00:52:11,450
So note that in this example, we used
this vesting datum type as datum, but

637
00:52:11,450 --> 00:52:15,319
the datum was just fixed, that was
just sitting there, it didn't change.

638
00:52:17,029 --> 00:52:22,340
And alternatively, we could bake
it into the contract, so to speak.

639
00:52:22,460 --> 00:52:27,590
So we can write a contract where the
script itself already contains this

640
00:52:27,590 --> 00:52:29,270
information, beneficiary and deadline.

641
00:52:30,020 --> 00:52:36,080
So all the examples of contracts we have
seen so far, they were always fixed.

642
00:52:36,140 --> 00:52:42,350
So we had this type validator,
and that was just of type typed

643
00:52:42,350 --> 00:52:47,170
validator, so it's a constant, a
compile time constant actually.

644
00:52:47,850 --> 00:52:51,060
So the idea of parameterized scripts
is that you can have a parameter.

645
00:52:51,300 --> 00:52:55,710
So depending on the value of
the parameter, you get different

646
00:52:55,710 --> 00:52:57,420
values of typed validator.

647
00:52:57,930 --> 00:53:02,070
So instead of just defining one
script, you, so to say, define

648
00:53:02,070 --> 00:53:06,750
a family of scripts that are
parameterized by a given parameter.

649
00:53:07,530 --> 00:53:12,700
So I want to demonstrate how we can
do this here by instead of using datum

650
00:53:12,750 --> 00:53:18,990
for these two pieces of information,
using a parameter so that the contract

651
00:53:18,990 --> 00:53:21,030
will be parameterized by this.

652
00:53:22,170 --> 00:53:26,670
So in order to do that, vesting
datum is no longer appropriate name.

653
00:53:26,700 --> 00:53:37,720
So let's call it vesting param instead,
and then we don't need the datum is data

654
00:53:37,740 --> 00:53:40,020
instance anymore, so let's remove that.

655
00:53:40,980 --> 00:53:44,640
Now this has to change, this now
gets an additional parameter,

656
00:53:44,850 --> 00:53:46,820
namely the parameter of the script.

657
00:53:47,235 --> 00:53:53,475
So vesting datum, and now comes the
datum and because all the information

658
00:53:53,475 --> 00:53:57,855
we needed until now in the datum is
now contained in this param here.

659
00:53:58,185 --> 00:54:01,425
We can simply use the unit type as datum.

660
00:54:02,565 --> 00:54:05,745
So this is now one parameter more,
the parameter of this script.

661
00:54:06,105 --> 00:54:10,695
So, by picking a specific value
of this parameter, I get what

662
00:54:10,695 --> 00:54:16,115
I had before, of type signature
datum, redeemer context to bool.

663
00:54:17,625 --> 00:54:20,775
And the code of course has to
change a little bit, but not much.

664
00:54:20,895 --> 00:54:28,275
So let's call the parameter argument P
and instead of dat, we now just have unit.

665
00:54:29,655 --> 00:54:35,235
And now all I have to do is I have
to exchange all the dats for Ps.

666
00:54:35,345 --> 00:54:38,615
So here P and here.

667
00:54:42,875 --> 00:54:43,325
Okay.

668
00:54:43,985 --> 00:54:49,500
So small change, now these vesting
type also has to change because

669
00:54:49,500 --> 00:54:54,330
now the datum type is no longer a
vesting datum, it's simply unit.

670
00:54:56,430 --> 00:54:58,860
Now we have to think what to do here.

671
00:54:59,340 --> 00:55:04,080
So this is now no longer, just a
constant, this typed validator, it now

672
00:55:04,080 --> 00:55:07,020
takes the parameter, so vesting param.

673
00:55:10,560 --> 00:55:11,820
So let's put that here.

674
00:55:14,040 --> 00:55:16,980
And now the question is
what to do with this.

675
00:55:17,460 --> 00:55:25,710
So the function make typed validator
expects as its first argument, the

676
00:55:25,710 --> 00:55:31,540
compiled code of something of type
datum to redeemer, to context to bool.

677
00:55:32,100 --> 00:55:35,279
But now this make validator doesn't
have this type anymore because

678
00:55:35,279 --> 00:55:39,360
it has this extra parameter P
so this wouldn't work like that.

679
00:55:40,170 --> 00:55:41,370
What we would like to do.

680
00:55:42,150 --> 00:55:45,660
Oh, and before I forget, I must
change this to unit as well.

681
00:55:46,410 --> 00:55:49,200
So what we would like
to do is put a P here.

682
00:55:50,010 --> 00:55:55,380
Now that the type would be correct
or it looks like that because

683
00:55:55,500 --> 00:55:57,350
P is this vesting param type.

684
00:55:57,370 --> 00:56:03,450
So if we apply, make validator to P
we apply the first argument here, and

685
00:56:03,450 --> 00:56:08,100
what we are left with is something of
type unit to unit to script context

686
00:56:08,100 --> 00:56:13,470
to bool which is a suitable type for
this make type validator function.

687
00:56:15,540 --> 00:56:20,580
Let's leave it like this for the moment,
and let's just change the rest because now

688
00:56:21,060 --> 00:56:25,440
all these things are no longer constance,
validator now also takes a parameter.

689
00:56:29,480 --> 00:56:38,110
And instead of doing this, we have
to compose it with typed validator.

690
00:56:40,830 --> 00:56:44,040
So actually, I mean, to write that
like more explicitly, we would

691
00:56:44,040 --> 00:56:50,340
have this P here and then it would
have to apply the P first to type

692
00:56:50,340 --> 00:56:52,300
validator to get a typed validator.

693
00:56:52,320 --> 00:56:56,430
And then we can apply validator script,
but in Haskell in simpler cases like

694
00:56:56,430 --> 00:57:01,650
that, we like to do a pointfree, so we
use function composition instead,, same

695
00:57:01,650 --> 00:57:09,270
for validator hash that now also takes
the vesting param type and same thing.

696
00:57:09,630 --> 00:57:14,970
Let's replace it with function
composition and script address as well.

697
00:57:16,259 --> 00:57:18,820
It's now also parameterized
by this parameter.

698
00:57:21,210 --> 00:57:30,030
However, if we go to the repl, then
we get a compiler error and it says

699
00:57:30,030 --> 00:57:34,020
"reference to a name which is not a
local, a builtin, or an external inlinable

700
00:57:34,020 --> 00:57:36,190
function: variable P no unfolding".

701
00:57:38,170 --> 00:57:40,780
And the problem is this.

702
00:57:41,140 --> 00:57:45,580
And as I explained, when I explained the
template Haskell and these Oxford brackets

703
00:57:46,660 --> 00:57:52,540
and the use of this inlinable Pragma,
I said that everything in the Oxford

704
00:57:52,570 --> 00:57:54,970
brackets must be known at compile time.

705
00:57:54,970 --> 00:57:56,200
It must be explicitly known.

706
00:57:56,230 --> 00:57:59,470
So normally it would even have
to be explicitly included,

707
00:57:59,500 --> 00:58:01,180
written inside these brackets.

708
00:58:01,509 --> 00:58:04,810
But by using this inlinable Pragma,
we can also have it in external

709
00:58:04,810 --> 00:58:06,960
functions, like our make validator.

710
00:58:08,250 --> 00:58:12,220
But it must still be known as
at compile time because that's

711
00:58:12,220 --> 00:58:13,879
how template Haskell works.

712
00:58:13,900 --> 00:58:19,950
If it is run it's executed before the main
compiler, the Haskell compiler is run.

713
00:58:19,980 --> 00:58:25,560
So at compiler time, template Haskell in
order to do this, to compile to Plutus

714
00:58:25,590 --> 00:58:30,360
core must know what is inside these
brackets, but the P of course is not

715
00:58:30,360 --> 00:58:35,820
known at compile time because we intend
to at run time, provide some arbitrary

716
00:58:36,330 --> 00:58:40,110
value of type vesting param and then
apply this function type validator to it.

717
00:58:40,560 --> 00:58:42,570
So the P will only be known at run time.

718
00:58:42,720 --> 00:58:47,910
And therefore this can't possibly work,
even though the types look correct.

719
00:58:49,650 --> 00:58:54,400
Luckily there's a way around
that, so what's the situation?

720
00:58:55,040 --> 00:59:02,670
On the Haskell side, we have our
make validator function and we

721
00:59:02,670 --> 00:59:05,380
have the P of type vesting param.

722
00:59:06,030 --> 00:59:13,890
And we could apply the one to
the other like this and that

723
00:59:13,980 --> 00:59:15,080
would have the right type.

724
00:59:16,035 --> 00:59:23,225
Now in the Plutus core side, we
can compile this because make

725
00:59:23,225 --> 00:59:26,045
validator is known at compile time.

726
00:59:27,635 --> 00:59:31,835
And I don't know how to write this
let's for example, put it into angular

727
00:59:31,835 --> 00:59:38,675
brackets to indicate that this is the
compiled to Plutus core version of

728
00:59:39,575 --> 00:59:41,805
the Haskell function make validator.

729
00:59:42,635 --> 00:59:52,715
And I want this, I want make validator
P compiled, but I can't apply compile

730
00:59:52,715 --> 00:59:57,685
here because the P is not known at
compile time, so template Haskell

731
00:59:57,705 --> 01:00:00,065
won't work for P so I can't do that.

732
01:00:01,560 --> 01:00:06,090
So now the idea is, in Plutus
this angular brackets make

733
01:00:06,090 --> 01:00:07,680
validator is also a function.

734
01:00:07,830 --> 01:00:10,320
It's not a Haskell function anymore,
it's a Plutus core function,

735
01:00:10,320 --> 01:00:14,460
but the function nevertheless,
that you can apply to arguments.

736
01:00:15,030 --> 01:00:23,610
So if I could get my hands on the
compile version of P, then what

737
01:00:23,610 --> 01:00:28,830
I could do, I can't do this here
directly, but then I can simply

738
01:00:29,760 --> 01:00:33,830
apply the make validator compiled.

739
01:00:35,430 --> 01:00:42,960
And actually that is called
apply code in Plutus to P,

740
01:00:43,980 --> 01:00:45,540
that would then be what I want.

741
01:00:46,455 --> 01:00:50,775
That would be the same as this, but
this looks as if it doesn't solve

742
01:00:50,775 --> 01:00:55,665
anything because we still need a
compiled version of P and we have the

743
01:00:55,665 --> 01:01:00,165
same problem that P is not known at
compile time, but only at run time.

744
01:01:00,765 --> 01:01:07,545
However, P is not some arbitrary
Haskell code, it's data, so it

745
01:01:07,545 --> 01:01:09,555
doesn't contain any function types.

746
01:01:10,995 --> 01:01:17,505
And as we would see for such types,
there is a way if we make the type

747
01:01:17,505 --> 01:01:22,095
of P in instance of a type class
called lift, that's called lift

748
01:01:22,095 --> 01:01:25,515
code, that does work at runtime.

749
01:01:26,685 --> 01:01:33,735
So using lift code, we can compile P
at run time to Plutus core, and then

750
01:01:33,735 --> 01:01:40,005
using apply code, we can apply this
function, this Plutus core function

751
01:01:40,185 --> 01:01:44,295
to this Plutus core value to get this.

752
01:01:45,705 --> 01:01:47,235
Which is exactly what we want.

753
01:01:48,225 --> 01:01:53,145
Let's briefly look at the lift class.

754
01:01:54,075 --> 01:01:58,705
It has one method lift, but we won't
use that method directly as I mentioned

755
01:01:58,705 --> 01:02:03,715
before, we will use something called
lift code, but lift code is available for

756
01:02:03,715 --> 01:02:06,535
types A that implement this lift class.

757
01:02:07,735 --> 01:02:08,845
And we see these...

758
01:02:09,115 --> 01:02:10,735
A bunch of instances for it.

759
01:02:11,025 --> 01:02:17,575
We can ignore this uni type parameter
here, but we see it's all for data,

760
01:02:17,875 --> 01:02:23,035
it's characters, byte strings,
integers, booleans, unit, data, I

761
01:02:23,035 --> 01:02:24,465
don't actually know what sqrt does...

762
01:02:25,225 --> 01:02:30,055
lists of things that have an
instance, maybe ratio and so on.

763
01:02:30,115 --> 01:02:38,490
Either pairs, maps, triples,
quadruplets, quintuples but no functions.

764
01:02:38,910 --> 01:02:42,210
And that's the reason why we
can't use lift code all the time.

765
01:02:42,360 --> 01:02:47,640
Not for compiling Haskell validators
to Plutus core validators, but we

766
01:02:47,640 --> 01:02:52,800
can use it for these data, like types
that are similar to the data type

767
01:02:53,550 --> 01:02:59,930
that we use to express our datum and
redeemers and the script context.

768
01:03:00,560 --> 01:03:05,780
So for those sort of types that are
data like, and not function like

769
01:03:06,620 --> 01:03:11,600
instances for the lift class are
available and then we can use lift code.

770
01:03:12,350 --> 01:03:14,610
So let's have a brief look at lift code.

771
01:03:14,960 --> 01:03:18,800
We can ignore these, the second
and the third precondition here.

772
01:03:19,130 --> 01:03:24,120
So if you have lift of A, then we have
a function from A to compile code of A.

773
01:03:25,220 --> 01:03:26,870
And that's exactly what we need.

774
01:03:27,860 --> 01:03:31,850
So if we go back to the code,
we can't do this, as I said.

775
01:03:33,105 --> 01:03:43,875
But we can use Plutus Tx apply
code and now lift code P.

776
01:03:45,375 --> 01:03:53,245
However, this won't compile, or
it's probably Plutus Tx lift code.

777
01:03:55,065 --> 01:04:00,665
However, this won't compile because
now the compiler complaints that we

778
01:04:00,665 --> 01:04:06,365
don't have a lift instance for vesting
param, but there something similar

779
01:04:06,365 --> 01:04:10,775
as true as what I said about is data,
there is a template Haskell mechanism

780
01:04:11,075 --> 01:04:13,565
to automatically get such an instance.

781
01:04:14,405 --> 01:04:23,105
So we can do Plutus Tx make
lift and vesting param.

782
01:04:26,895 --> 01:04:32,955
Now we get another error, illegal instance
declaration, use multi param type classes.

783
01:04:33,255 --> 01:04:38,045
It is because we saw this lift class
had additional type parameters.

784
01:04:38,295 --> 01:04:42,765
So in standard Haskell 98, you can
only have one type parameter for

785
01:04:42,765 --> 01:04:47,265
a class, but lift uses more and
that is enabled by this extension.

786
01:04:47,295 --> 01:04:49,515
So we have to add this to our extensions.

787
01:04:53,025 --> 01:04:56,585
Try again, it compiles.

788
01:04:57,225 --> 01:05:00,225
Now let's briefly look at the
off-chain code, which hasn't

789
01:05:00,285 --> 01:05:01,995
changed much, but somewhat.

790
01:05:02,685 --> 01:05:04,455
So the give parameters are still the same.

791
01:05:05,655 --> 01:05:08,325
I must know the beneficiary,
the deadline and the amount.

792
01:05:08,865 --> 01:05:13,215
The schema has slightly changed, the
one for give is still the same, but for

793
01:05:13,215 --> 01:05:15,555
grab, we now need to know the deadline.

794
01:05:16,035 --> 01:05:21,524
Because in order to find the UTxOs of
gifts that are locked at the script.

795
01:05:21,825 --> 01:05:25,424
Now, because the script address
depends on these parameters, the

796
01:05:25,435 --> 01:05:26,745
beneficiary and the deadline.

797
01:05:27,015 --> 01:05:29,424
We need those in order to find the UTxOs.

798
01:05:29,485 --> 01:05:33,214
We know the beneficiary, that will be
the pub key hash of the wallet that calls

799
01:05:33,214 --> 01:05:35,444
grab, but we can't know the deadline.

800
01:05:35,535 --> 01:05:37,754
So I made that parameter here.

801
01:05:38,625 --> 01:05:44,265
So the give endpoint is very similar, but
instead of computing the datum, we just

802
01:05:44,265 --> 01:05:49,185
define something of type vesting param
and then this must pay to the script,

803
01:05:49,214 --> 01:05:54,464
now the datum is just unit, and here
when we submit the transaction, now we...

804
01:05:55,214 --> 01:05:58,935
typed validator is no longer constant,
so we provide this parameter P that

805
01:05:58,935 --> 01:06:01,395
we define, the rest is the same.

806
01:06:02,355 --> 01:06:07,584
Grab is now different, recall,
earlier we got all the UTxOs

807
01:06:07,604 --> 01:06:09,645
sitting at this one script address.

808
01:06:10,410 --> 01:06:14,609
And that could be for arbitrary
beneficiaries and for arbitrary deadlines.

809
01:06:14,640 --> 01:06:19,319
So we had to filter those UTxOs
that were for us and where

810
01:06:19,319 --> 01:06:21,270
the deadline had been reached.

811
01:06:21,779 --> 01:06:23,250
Now, the situation is different.

812
01:06:23,279 --> 01:06:27,959
So we, again, check what is now
and we check our own public key.

813
01:06:28,319 --> 01:06:32,649
And now we do know the deadline in advance
because it's a parameter to this grab.

814
01:06:33,450 --> 01:06:36,750
So we can immediately see whether
the deadline has been reached or not.

815
01:06:36,839 --> 01:06:40,560
So if it has not yet been
reached, we simply log a message

816
01:06:40,589 --> 01:06:41,970
that it's too early and stop.

817
01:06:42,600 --> 01:06:46,569
If it has been reached, we can
compute the vesting params.

818
01:06:46,589 --> 01:06:51,660
We have the beneficiary and the deadline,
and we lookup the UTxOs at this address.

819
01:06:51,689 --> 01:06:55,049
Now address again is not a constant
anymore, but takes this parameter.

820
01:06:55,620 --> 01:07:00,509
So now we will only get UTxOs that
are for us and for this deadline

821
01:07:00,509 --> 01:07:04,230
D and we know that all of them
are available, so we don't have to

822
01:07:04,230 --> 01:07:08,009
filter anything because we already
checked that the deadline has passed.

823
01:07:09,149 --> 01:07:12,650
So, all we do is, we check whether
there are none and if they are

824
01:07:12,650 --> 01:07:15,210
none, we don't even bother and
just say no gifts available.

825
01:07:15,629 --> 01:07:19,169
And if there is, then we do
more or less what we did before.

826
01:07:19,350 --> 01:07:24,299
So we defined the lookups that
define these UTxOs and the script.

827
01:07:25,140 --> 01:07:30,359
And the constraint is that we want to
spend all those UTxOS that we found.

828
01:07:30,660 --> 01:07:33,480
And that it must validate in
the right validity interval.

829
01:07:34,649 --> 01:07:38,879
And we submit as before, wait for
confirmation and log a message.

830
01:07:39,240 --> 01:07:41,910
The endpoint is only slightly
different now here in grab,

831
01:07:41,910 --> 01:07:43,620
because we have this one parameter.

832
01:07:45,060 --> 01:07:46,830
Let's test this in the playground.

833
01:07:46,859 --> 01:07:51,750
I copied the code into the editor
and compiled, and I already added

834
01:07:51,750 --> 01:07:56,129
the third wallet and did exactly
the same give actions as before.

835
01:07:56,129 --> 01:08:01,819
So wallet one gives 10 ADA each, twice
to wallet two, once to wallet three.

836
01:08:02,299 --> 01:08:05,745
And for wallet two the deadlines
are slot 10 and slot 20 and

837
01:08:05,745 --> 01:08:07,755
for wallet three it's slot 20.

838
01:08:08,595 --> 01:08:13,545
Now the grab is slightly different
because in our earlier implementation,

839
01:08:13,965 --> 01:08:17,925
one beneficiary, one wallet could
grab different deadlines provided

840
01:08:17,925 --> 01:08:22,305
that had passed, but now the deadline
is part of the script parameter.

841
01:08:22,365 --> 01:08:27,885
So it's also part of the
parameter for the endpoint, so

842
01:08:27,885 --> 01:08:29,104
we have to specify the deadline.

843
01:08:29,104 --> 01:08:35,024
So, wallet two can't grab the gift
for slot 10 and 20 at the same

844
01:08:35,024 --> 01:08:36,765
time, the way I implemented it.

845
01:08:37,845 --> 01:08:39,404
So let's see.

846
01:08:39,495 --> 01:08:44,895
So first we can wait until slot 10 and
then wallet two should be able to grab the

847
01:08:44,895 --> 01:08:47,715
first gift and wallet three the only gift.

848
01:08:48,345 --> 01:08:52,694
So let's add a grab for wallet two and
three, and we don't have to wait in

849
01:08:52,694 --> 01:08:55,844
between because it's to different wallets.

850
01:08:55,965 --> 01:08:59,805
So if the one blocks until it's confirmed,
the other ones should still work.

851
01:09:00,165 --> 01:09:03,915
So now we need one parameter, namely the
deadline, which in this case is slot 10.

852
01:09:03,915 --> 01:09:05,444
So that's this value here.

853
01:09:07,274 --> 01:09:07,755
Okay.

854
01:09:07,814 --> 01:09:10,394
Now let's wait for slot 20.

855
01:09:12,765 --> 01:09:18,615
Well, now wallet two can grab, second
time, as parameter we need slot 20.

856
01:09:18,765 --> 01:09:19,845
That should be this one.

857
01:09:20,835 --> 01:09:25,875
We need to wait for one more
block and check whether works.

858
01:09:28,545 --> 01:09:29,865
It seems to have worked.

859
01:09:30,255 --> 01:09:34,005
So let's go through the transactions
quickly again, Genesis in the beginning.

860
01:09:34,965 --> 01:09:38,334
Now this is the first gift
from wallet one to wallet two.

861
01:09:38,964 --> 01:09:43,075
And take note of the script
address, it starts with a58.

862
01:09:43,665 --> 01:09:47,335
Now the second transaction is
from wallet one to wallet two

863
01:09:47,354 --> 01:09:49,095
with the slot 20 deadline.

864
01:09:49,724 --> 01:09:54,104
And this script address is now different,
so earlier in our first version,

865
01:09:54,615 --> 01:09:56,235
the script address was a constant.

866
01:09:56,295 --> 01:10:02,265
So all our gift ended up at the same
script address and only the datum in those

867
01:10:02,265 --> 01:10:05,625
three UTxO was different, with different
beneficiary and different deadline.

868
01:10:05,635 --> 01:10:09,965
Now the datum is just unit and the
beneficiary and the deadline are

869
01:10:10,035 --> 01:10:14,525
included as part of this script itself,
so the addresses are different now,

870
01:10:15,315 --> 01:10:17,429
depending on beneficiary and deadline.

871
01:10:17,759 --> 01:10:22,469
So this is the second gift to wallet
two, this is the gift to wallet

872
01:10:22,500 --> 01:10:24,630
three, again, a different address.

873
01:10:25,320 --> 01:10:30,600
Now in slot 10, we see concurrently
both wallet two and three grabs.

874
01:10:30,620 --> 01:10:32,759
So this is the one of wallet three.

875
01:10:32,759 --> 01:10:35,820
So this is deterministic in
which order they are processed.

876
01:10:36,719 --> 01:10:44,940
So wallet three gets this one gift
that was for wallet three and grabs it.

877
01:10:45,179 --> 01:10:48,030
And wallet two gets the
first gift and grabs it.

878
01:10:48,059 --> 01:10:54,210
And finally in slot 24, wallet two gets
the second gift and successfully grabs it.

879
01:10:55,259 --> 01:11:00,330
We see the balances at app, so
wallet one ends up with roughly

880
01:11:00,330 --> 01:11:06,450
70, wallet two with roughly 120
and wallet three with roughly 110.

881
01:11:09,735 --> 01:11:13,155
For the first part of this week's
homework, I've taken the vesting

882
01:11:13,155 --> 01:11:16,515
contract and changed the vesting datum.

883
01:11:16,545 --> 01:11:19,035
So I added a second beneficiary.

884
01:11:19,125 --> 01:11:21,465
So now we have two and the deadline.

885
01:11:22,665 --> 01:11:29,485
And the idea of validation
should now be that up till the

886
01:11:29,485 --> 01:11:33,125
deadline, beneficiary one can grab.

887
01:11:33,865 --> 01:11:37,175
And once the deadline has
passed beneficiary two can grab.

888
01:11:38,515 --> 01:11:44,545
So it's like you make a gift to
beneficiary one, but beneficiary one

889
01:11:44,545 --> 01:11:50,785
only has time till the deadline to
retrieve it, otherwise you can get it

890
01:11:50,785 --> 01:11:54,165
back if you self are beneficiary too.

891
01:11:54,185 --> 01:11:57,344
Of course it's more general here.

892
01:11:58,184 --> 01:12:01,754
So your task is simply to
write the correct logic here.

893
01:12:03,165 --> 01:12:04,835
Everything else should be complete.

894
01:12:04,835 --> 01:12:06,875
And I also modified the give and grab.

895
01:12:08,974 --> 01:12:17,044
So the give simply sets the given
beneficiary as beneficiary one and

896
01:12:17,105 --> 01:12:19,815
the wallet itself as beneficiary two.

897
01:12:20,105 --> 01:12:26,884
So the giver can get or can grab back once
the deadline has been reached and passed.

898
01:12:28,044 --> 01:12:38,535
And grab now filters the UTxOs
into two different UTxOs sets.

899
01:12:39,825 --> 01:12:47,765
One checks that this wallet is beneficiary
one and the deadline has not yet passed.

900
01:12:48,155 --> 01:12:53,045
And the second checks that
this wallet is beneficiary two

901
01:12:53,105 --> 01:12:54,785
and the deadline has passed.

902
01:12:55,535 --> 01:13:00,394
And then it generates
transactions accordingly could

903
01:13:00,394 --> 01:13:01,684
be one or two transactions.

904
01:13:01,684 --> 01:13:06,035
So one transaction for the UTxOs in
the first group and one transaction

905
01:13:06,065 --> 01:13:08,165
for the UTxOs in the second group.

906
01:13:08,525 --> 01:13:14,465
I need two different transactions because
the validation interval must be different.

907
01:13:14,825 --> 01:13:20,195
For the first group I must use
two now, I must make sure that the

908
01:13:20,195 --> 01:13:24,155
deadline has not yet been reached
or has reached, but not passed.

909
01:13:24,724 --> 01:13:29,585
And for the second group of UTxOs
if I want to grab them, I must use a

910
01:13:29,585 --> 01:13:31,715
different validity interval from now.

911
01:13:32,594 --> 01:13:36,375
To try this out in the playground
to see the expected behavior.

912
01:13:37,155 --> 01:13:39,615
I copied my solution in
the editor and compiled.

913
01:13:40,545 --> 01:13:44,865
Now only need need two wallets
with the initial 100 ADA.

914
01:13:47,545 --> 01:13:53,735
By doing two gives, one from wallet one,
one from wallet two in the same slot.

915
01:13:54,695 --> 01:13:59,275
So the beneficiary of wallet one's
gift is wallet two and the beneficiary

916
01:13:59,275 --> 01:14:01,235
of wallet two's gift is wallet one.

917
01:14:02,105 --> 01:14:05,525
The deadline of the first gift is slot 10.

918
01:14:06,185 --> 01:14:10,235
The deadline of the second gift is slot 5.

919
01:14:11,045 --> 01:14:11,945
So what does that mean?

920
01:14:11,945 --> 01:14:16,895
That means here until slot
10 wallet two can grab it.

921
01:14:17,345 --> 01:14:23,945
And after that, wallet one can get it
back and here until slot 5, wallet one can

922
01:14:23,945 --> 01:14:30,700
get it and after slot 5, wallet two can
get it back, So now I wait until slot 6.

923
01:14:31,200 --> 01:14:34,290
So that means this deadline, here
the first deadline has not yet been

924
01:14:34,290 --> 01:14:36,009
reached so wallet two can still grab.

925
01:14:36,839 --> 01:14:39,900
But the second deadline
has already passed.

926
01:14:40,290 --> 01:14:44,440
So wallet two can get it back, so
at that point slot 6 wallet two

927
01:14:44,460 --> 01:14:47,160
should be able to grab both gifts.

928
01:14:47,610 --> 01:14:53,700
So I do a grab and wait for
another block and then evaluate,

929
01:14:55,080 --> 01:14:56,849
and we see that it has worked.

930
01:14:56,940 --> 01:14:59,160
So let's go through the transactions.

931
01:15:00,870 --> 01:15:05,670
As always Genesis transaction,
initial funds, then the two gives.

932
01:15:08,780 --> 01:15:13,730
This is the one from
wallet two to wallet one.

933
01:15:15,309 --> 01:15:18,750
So 50 ADA are locked
at the script address.

934
01:15:19,320 --> 01:15:24,360
And this is the one from wallet one
to wallet two, again 50 ADA locked.

935
01:15:25,260 --> 01:15:31,679
And these other two grabs from wallet two.

936
01:15:31,740 --> 01:15:34,450
So, wallet two collects the one donation.

937
01:15:35,360 --> 01:15:40,730
This is the one, this one,
the one from wallet two, so

938
01:15:40,760 --> 01:15:42,650
from itself, it gets it back.

939
01:15:43,309 --> 01:15:46,190
And that one is the give from wallet one.

940
01:15:46,700 --> 01:15:52,050
So indeed as expected, wallet
one ends up with roughly 50 ADA

941
01:15:52,910 --> 01:15:55,090
and wallet two with 150 ADA.

942
01:15:56,809 --> 01:16:00,380
And I just want to point out
that we can also nicely see the

943
01:16:00,380 --> 01:16:01,910
different validity intervals.

944
01:16:02,360 --> 01:16:07,615
So, this grab uses the
one that starts at slot 6.

945
01:16:08,505 --> 01:16:13,125
And that grab uses the
one that ends at stop six.

946
01:16:13,365 --> 01:16:18,675
For the second part of the homework,
I want you to revisit the vesting,

947
01:16:18,705 --> 01:16:20,885
the original vesting once again.

948
01:16:21,485 --> 01:16:25,265
And remember we had two versions
of the original one to one with

949
01:16:25,265 --> 01:16:26,945
one beneficiary and one deadline.

950
01:16:27,445 --> 01:16:32,825
The unparameterized version where the
datum carried both beneficiary and

951
01:16:32,825 --> 01:16:38,435
deadline, and then a parameterized
version where both beneficiary and

952
01:16:38,435 --> 01:16:43,085
deadline were now the parameter
and the datum turned into unit.

953
01:16:43,805 --> 01:16:50,145
And for this homework, I would like you
to do another parameterized version where

954
01:16:50,145 --> 01:16:56,385
we split beneficiary and deadline between
parameter of the contract and datum.

955
01:16:56,865 --> 01:17:02,415
So the signature of the validator, make
validator function will be like this.

956
01:17:02,415 --> 01:17:07,505
Pub key hash is the parameter of the
contract and deadline is the datum.

957
01:17:08,115 --> 01:17:11,805
So we split these two pieces
of information into parameter.

958
01:17:13,205 --> 01:17:16,665
So then you have to implement this.

959
01:17:16,665 --> 01:17:20,325
So the logic is the same, but
now the data just comes from

960
01:17:20,385 --> 01:17:21,775
these two different sources.

961
01:17:23,195 --> 01:17:26,835
And then just write this boiler plate.

962
01:17:27,945 --> 01:17:34,395
And I adopted the wallet endpoints,
the wallet contracts accordingly.

963
01:17:35,385 --> 01:17:40,305
So now it's actually nicer again, the
grab, or it depends how you look at it,

964
01:17:40,605 --> 01:17:45,385
but the grab now, again, doesn't need a
parameter, because it gets the beneficiary

965
01:17:45,405 --> 01:17:47,985
by just taking its own public key hash.

966
01:17:50,195 --> 01:17:54,305
And it does no longer need the
deadline in order to construct the

967
01:17:54,305 --> 01:17:57,695
address, because now the deadline is
no longer part of the address because

968
01:17:57,695 --> 01:17:59,525
it's no longer part of the parameter.

969
01:18:01,055 --> 01:18:05,375
And I had to change the logic a bit,
but actually it gets much simpler.

970
01:18:05,615 --> 01:18:10,385
So maybe this is actually the right way
to do it, to take the beneficiary in

971
01:18:10,385 --> 01:18:15,465
the, as a parameter of the contract,
but put the deadline into the datum.

972
01:18:16,235 --> 01:18:19,844
To try this in the playground,
I have two wallets.

973
01:18:20,655 --> 01:18:26,144
And wallet one makes two gifts, so I
have to wait for one block in between.

974
01:18:27,424 --> 01:18:32,235
Both gifts are to wallet two, so this
is the pub key hash of wallet two, but

975
01:18:32,325 --> 01:18:34,245
different deadlines and different amounts.

976
01:18:34,605 --> 01:18:40,424
So this is slot 10 and this is
slot 20 and 40 ADA and 30 ADA.

977
01:18:41,054 --> 01:18:45,434
So after slot 10, this should be
available and after slot 20 this.

978
01:18:46,245 --> 01:18:49,605
Then I wait until slot 10
and wallet two does a grab.

979
01:18:50,115 --> 01:18:54,014
So it should be able to grab the
first gift, but not yet the second.

980
01:18:54,705 --> 01:18:59,264
And I wait until slot 20 and wallet
two grabs again, and now should

981
01:18:59,264 --> 01:19:03,434
be able to retrieve this gift as
well and I wait for one more block.

982
01:19:05,594 --> 01:19:09,585
So let's go through the
transactions, initial distribution

983
01:19:09,585 --> 01:19:12,135
of funds, then the first gift...

984
01:19:14,045 --> 01:19:16,585
locking 40.

985
01:19:16,605 --> 01:19:18,705
So this is the one for with deadline 10.

986
01:19:19,365 --> 01:19:22,724
The second gift with deadline 20 30.

987
01:19:23,985 --> 01:19:29,144
The first grab of wallet two, it picks
up the first gift, but not the second

988
01:19:30,855 --> 01:19:33,935
and collects the roughly 40 ADA.

989
01:19:34,125 --> 01:19:39,705
And then in slot 20 wallet two picks up
the other gift and collects the 30 ADA.

990
01:19:43,275 --> 01:19:51,675
If instead, I immediately wait until slot
20, then I can remove the second grab.

991
01:19:55,655 --> 01:19:58,835
And this final wait and try again.

992
01:20:01,925 --> 01:20:05,375
Then the first three transactions
are the same, here the

993
01:20:05,465 --> 01:20:07,205
first gift, the second gift.

994
01:20:07,925 --> 01:20:12,965
But then in slot 20 wallet two was able
to grab both of them simultaneously.

995
01:20:13,860 --> 01:20:17,970
The 30 and the 40 gift and
collect 70 in one transaction.

996
01:20:20,280 --> 01:20:27,930
So this concludes the third lecture and
we have now looked at validation scripts

997
01:20:28,110 --> 01:20:29,820
that actually look at the context.

998
01:20:29,880 --> 01:20:35,850
We have looked at the type that
defines the context, and we have seen

999
01:20:35,850 --> 01:20:40,860
examples of how to use it, in this,
in the form of this vesting contract.

1000
01:20:40,860 --> 01:20:45,450
And we have particular discussed how
time sensitive contracts or validation

1001
01:20:45,450 --> 01:20:47,280
logic can be written in Plutus.

1002
01:20:48,330 --> 01:20:51,690
And we have seen how to write
parameterized contracts.

